{"key":"xml-dom","pages":[{"script":"const { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\n// You can load an XML DOM from a string or Buffer with XmlDocumentNode.from()\nconst doc = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"list_of_tuples\">\n    <U>\n      <T n=\"tunable\">67890<!--something--></T>\n      <E n=\"enum_value\">VALUE_1</E>\n    </U>\n    <U>\n      <T n=\"tunable\">24680<!--something_else--></T>\n      <E n=\"enum_value\">VALUE_2</E>\n    </U>\n  </L>\n</I>\n`);\n\n// Remember, the document node itself is invisible; it is just a wrapper for\n// the \"real\" nodes. What you really want is the root, which in this case, is\n// the <I> tag. You can get the root of a document with the `child` property.\nconst root = doc.child;\n\n// We'll discuss element nodes and their properties next, but for now, just know\n// that you can get an element node's tag with the `tag` property.\nconst rootTag = root.tag;\n\n// Let's make sure the root's tag is \"I\", to verify that the document loaded\nSandbox.test('Root tag should be \"I\"', rootTag === \"I\");\n","guide":"<h2>XML Documents</h2>\n<p>\n  XML is a data format that means nothing on its own. In order for it to have\n  meaning, it must be loaded into a Document Object Model (DOM). The S4TK module\n  that handles XML DOMs is called @s4tk/xml-dom.\n</p>\n\n<h4>Nodes</h4>\n<p>\n  At the core of XML DOMs are <strong>nodes</strong>. \"Node\" is a vague term for\n  pretty much anything in an XML DOM, such as an element/tag (like\n  <code>&lt;T /&gt;</code>), a value (like <code>0x00000000</code>), or a\n  comment (like <code>&lt;!--...--&gt;</code>).\n</p>\n<p>\n  Some nodes, like elements, are able to contain other nodes. These are called\n  <strong>parents</strong>, and the nodes they contain are their\n  <strong>children</strong>. For example, an <code>&lt;L /&gt;</code> node that\n  contains several <code>&lt;T /&gt;</code> nodes is a parent, and the\n  <code>&lt;T /&gt;</code> nodes are its children.\n</p>\n<p>\n  Everything in an XML DOM is a node, including the document itself. The\n  document node is just a wrapper for the node(s) at the highest level, i.e. the\n  node(s) from which all other nodes descend. In properly structured XML, there\n  should only be one* node without a parent, such as <code>&lt;I /&gt;</code>.\n  This child is called the <strong>root</strong>.\n</p>\n<p class=\"footnote\">\n  * The line that begins with \"&lt;?xml\" is called a processing instruction, and\n  can be ignored for the sake of this lesson.\n</p>\n\n<h4>Parsing XML Documents</h4>\n<p>\n  If the last section was too abstract for you to digest, take a look at the\n  script editor for a real example. In the XML document created for the\n  <code>doc</code> variable, <code>&lt;I&gt;</code> is the root node. It is a\n  parent with one child, <code>&lt;L&gt;</code>. <code>&lt;L&gt;</code> is also\n  a parent to the two <code>&lt;U&gt;</code> nodes, and each\n  <code>&lt;U&gt;</code> is a parent to a <code>&lt;T&gt;</code> and an\n  <code>&lt;E&gt;</code>. Even those <code>&lt;T&gt;</code> and\n  <code>&lt;E&gt;</code> nodes are parents - their children are the value and\n  comment nodes they contain, but we'll get back to that later.\n</p>\n<p>\n  You'll notice that the XML string is being parsed into a DOM with\n  <code>XmlDocumentNode.from(xml: string | Buffer)</code>. This static method\n  returns an instance of the <code>XmlDocumentNode</code> class, which\n  represents an XML document for the given string/buffer.\n</p>\n\n<h4>The Root Node</h4>\n<p>\n  As mentioned before, the root of this document is <code>&lt;I&gt;</code>, as\n  it is the node from which everything else descends. To access it, you can use\n  the <code>doc</code>'s <code>child</code> property (the\n  <code>children</code> property is a list of all of a node's children, and\n  <code>child</code> is just an alias for <code>children[0]</code>).\n</p>\n<p>\n  In the vast majority of XML documents, and 100% of TS4 XML documents, the root\n  node is going to be an element. Elements are nodes that have a tag,\n  attributes, and children. You'll read more about these on the next page.\n</p>\n"},{"script":"const { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\n// There is no need to import XmlElementNode, since we're never using the class\n// itself or its constructor. Creating new XmlElementNodes will be covered on\n// a later page.\n\n// This is the same doc loaded on the last page, but we're using the `child`\n// property to get the root immediately -- remember, `root` is the <I> node,\n// which is an instance of the XmlElementNode class\nconst root = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"list_of_tuples\">\n    <U>\n      <T n=\"tunable\">67890<!--something--></T>\n      <E n=\"enum_value\">VALUE_1</E>\n    </U>\n    <U>\n      <T n=\"tunable\">24680<!--something_else--></T>\n      <E n=\"enum_value\">VALUE_2</E>\n    </U>\n  </L>\n</I>\n`).child;\n\n// ==================================================\n// Tags\n\n// Just for posterity, let's check the tag value again, make sure it's \"I\"\nSandbox.test('root.tag should be \"I\"', root.tag === \"I\");\n\n// Even though you'd probably never do this, it's possible to set the tag\nroot.tag = \"M\";\n\n// If you check the tag now, or write the XML as a string, you'll see that\n// the entire thing is now contained in `<M>...</M>`\n\n// ==================================================\n// Attributes\n\n// To access attributes, use `attributes`\nSandbox.test(\n  'root.attributes.n should be \"some_tuning\"',\n  root.attributes.n === \"some_tuning\"\n);\n\n// Some attributes, like `n`, have aliases\nSandbox.test('root.name should be \"some_tuning\"', root.name === \"some_tuning\");\n\n// To set an attribute's value, just set its key on the `attributes` object\nroot.attributes.n = \"fancy_new_name\";\nSandbox.output(`File name changed to \"${root.name}\"`);\n\n// If an attribute has an alias, you can also set that\nroot.name = \"fancier_newer_name\";\nSandbox.output(`File name changed to \"${root.attributes.n}\"`);\n\n// Notice how `attributes.n` and `name` are fully in sync with each other.\n// When you update one, the other changes -- that's because they're the exact\n// same thing. This also goes for all other attribute aliases.\n\n// One thing to be mindful of is that all attributes are parsed as strings.\n// Yes, even `s` -- if it were parsed as a number, it would lose precision.\nSandbox.test(\"root.id should be a string\", typeof root.id === \"string\");\n\n// If you need the tuning ID as a number, you MUST use a bigint -- numbers lose\n// precision after 53 bits, and tuning IDs can go up to 64 bits\nconst tuningID = BigInt(root.id);\nSandbox.test(\"tuningID should be a bigint\", typeof tuningID === \"bigint\");\n\n// ==================================================\n// Children\n\n// To access an element's children list, use `children`\nSandbox.test(\"root should only have one child\", root.children.length === 1);\n\n// You can also use `child` to get the first node in `children`\nSandbox.test(\"root's child should be an L tag\", root.child.tag === \"L\");\nSandbox.test(\n  'root\\'s child should ne named \"list_of_tuples\"',\n  root.child.name === \"list_of_tuples\"\n);\n","guide":"<h2>Element Nodes</h2>\n<p>\n  As mentioned on the last page, elements are nodes that have a tag, attributes,\n  and children. Elements in an S4TK XML DOM are represented with the\n  <code>XmlElementNode</code> class.\n</p>\n\n<h4>Tags</h4>\n<p>\n  Every element <strong>must</strong> have a tag. The tag is the value that\n  appears between <code>&lt;</code> and <code>&gt;</code> in the opening and\n  closing parts of the element node. For instance, the tag for\n  <code>&lt;I&gt;</code> is <code>I</code>.\n</p>\n<p>\n  You can get and set the tag of an <code>XmlElementNode</code> with its\n  <code>tag</code> property.\n</p>\n\n<h4>Attributes</h4>\n<p>\n  Elements may have attributes, but they are not required. Attributes are\n  key/value pairs that appear in the opening tag of an element node, such as\n  <code>n=\"name\"</code> in <code>&lt;T n=\"name\"&gt;</code>.\n</p>\n<p>\n  You can access an <code>XmlElementNode</code>'s attributes with its\n  <code>attributes</code> property, which is an object. To get, set, and delete\n  attributes, just edit <code>attributes</code> as you would any other object.\n</p>\n<p>\n  When setting the values of attributes, you can use strings, numbers, or\n  bigints. However, when an <code>XmlDocumentNode</code> is parsed, the value of\n  every attribute will always be a string. That is, even if the\n  <code>s</code> attribute contains the value <code>12345</code>, it will be\n  parsed as the string <code>\"12345\"</code> rather than the number\n  <code>12345</code>*.\n</p>\n<p class=\"footnote\">\n  * This is because the XML parser works with numbers only, not bigints. Numbers\n  in JavaScript lose precision after around 53 bits, and numbers in tuning can\n  be as high as 64 bits. If you need the tuning ID as a bigint, you must\n  manually parse the string with\n  <a\n    href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\"\n    target=\"_blank\"\n    ><code>BigInt()</code></a\n  >.\n</p>\n\n<h4>Attribute Aliases</h4>\n<p>\n  Some common attributes (<code>n</code>, <code>s</code>, and <code>t</code>)\n  also have aliases, to make working with them a bit easier (i.e. they have\n  properties on the node itself, rather than having to use\n  <code>attributes</code>).\n</p>\n<p>\n  To get the <code>n</code> attribute of a node, you can use <code>name</code>.\n  For <code>s</code>, you can use <code>id</code>. And finally, for\n  <code>t</code>, you can use <code>type</code>.\n</p>\n<p>\n  For any other attributes (like <code>c</code>, <code>m</code>, <code>i</code>,\n  and <code>p</code>), you <strong>must</strong> use the\n  <code>attributes</code> property and get them by name. These attributes do not\n  have aliases for two reasons:\n</p>\n<ol>\n  <li>You're unlikely to need them.</li>\n  <li>There are no good options*.</li>\n</ol>\n<p class=\"footnote\">\n  *<code>class</code>/<code>module</code> are reserved words and cannot be used\n  for <code>c</code>/<code>m</code>; <code>instanceType</code> is too long and\n  <code>type</code> is taken by <code>t</code>, neither is good option for\n  <code>i</code>; who cares about <code>p</code>?\n</p>\n\n<h4>Children</h4>\n<p>\n  As mentioned on the previous page, an element node can contain an arbitrary\n  number of other nodes, which are called its children. These children can\n  either be other element nodes (like an <code>&lt;L&gt;</code> that contains\n  <code>&lt;T&gt;</code>s), or they can be value nodes (like a\n  <code>&lt;T&gt;</code> that contains <code>0x12345678</code>).\n</p>\n<p>\n  You can get access an <code>XmlElementNode</code>'s children with its\n  <code>children</code> property. There is also the <code>child</code> property,\n  which is an alias for the first item in the children list\n  (<code>children[0]</code>).\n</p>\n\n<h4>Creating New Elements</h4>\n<p>\n  You've learned how to use <code>XmlElementNode</code>s once you have them, but\n  you may be wondering how you can create a new one to add to an existing DOM.\n</p>\n<p>\n  In order to do this, you need to read about value nodes, so let's do that\n  first on the next page.\n</p>\n"},{"script":"","guide":"<h2>Value & Comment Nodes</h2>\n<p>\n  Value nodes are much simpler than element nodes. They are just a single value,\n  such as a string, number, or boolean. Comments are even easier, as they are\n  just a string.\n</p>\n\n<h4>Parsing Values</h4>\n<p>\n  Like attributes of elements, the XML parser will always load the value of an\n  <code>XmlValueNode</code> as a string, even if it's a number. This is again\n  due to precision errors with 64 bit numbers. If you need the value as a\n  number, you must parse it with\n  <a\n    href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\"\n    target=\"_blank\"\n    ><code>BigInt()</code></a\n  >.\n</p>\n\n<h4>Getting & Setting Values</h4>\n<p>\n  You can get or set the value of both <code>XmlValueNode</code>s and\n  <code>XmlCommentNode</code>s with their <code>value</code> property.\n</p>\n"},{"script":"","guide":"<h2>Creating New Nodes</h2>\n"},{"script":"","guide":"<h2>Final Notes</h2>\n<p>Blah blah</p>\n\n<h4>Helper Methods</h4>\n<p>\n  Some methods that you may find especially helpful are <code>clone()</code>,\n  <code>findChild()</code>, and <code>sort()</code>.\n</p>\n"}],"media":{}}