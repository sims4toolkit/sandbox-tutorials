{"key":"xml-dom","pages":[{"script":"const { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\n// You can load an XML DOM from a string or Buffer with XmlDocumentNode.from()\nconst doc = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"list_of_tuples\">\n    <U>\n      <T n=\"tunable\">67890<!--something--></T>\n      <E n=\"enum_value\">VALUE_1</E>\n    </U>\n    <U>\n      <T n=\"tunable\">24680<!--something_else--></T>\n      <E n=\"enum_value\">VALUE_2</E>\n    </U>\n  </L>\n</I>\n`);\n\n// Remember, the document node itself is invisible; it is just a wrapper for\n// the \"real\" nodes. What you really want is the root, which in this case, is\n// the <I> tag. You can get the root of a document with the `child` property.\nconst root = doc.child;\n\n// We'll discuss element nodes and their properties next, but for now, just know\n// that you can get an element node's tag with the `tag` property.\nconst rootTag = root.tag;\n\n// Let's make sure the root's tag is \"I\", to verify that the document loaded\nSandbox.test('Root tag should be \"I\"', rootTag === \"I\");\n","guide":"<h2>XML Documents</h2>\n<p>\n  XML is a data format that means nothing on its own. In order for it to have\n  meaning, it must be loaded into a Document Object Model (DOM). The S4TK module\n  that handles XML DOMs is called @s4tk/xml-dom.\n</p>\n\n<h4>Nodes</h4>\n<p>\n  At the core of XML DOMs are <strong>nodes</strong>. \"Node\" is a vague term for\n  pretty much anything in an XML DOM, such as an element/tag (like\n  <code>&lt;T /&gt;</code>), a value (like <code>0x00000000</code>), or a\n  comment (like <code>&lt;!--...--&gt;</code>).\n</p>\n<p>\n  Some nodes, like elements, are able to contain other nodes. These are called\n  <strong>parents</strong>, and the nodes they contain are their\n  <strong>children</strong>. For example, an <code>&lt;L /&gt;</code> node that\n  contains several <code>&lt;T /&gt;</code> nodes is a parent, and the\n  <code>&lt;T /&gt;</code> nodes are its children.\n</p>\n<p>\n  Everything in an XML DOM is a node, including the document itself. The\n  document node is just a wrapper for the node(s) at the highest level, i.e. the\n  node(s) from which all other nodes descend. In properly structured XML, there\n  should only be one* node without a parent, such as <code>&lt;I /&gt;</code>.\n  This child is called the <strong>root</strong>.\n</p>\n<p class=\"footnote\">\n  * The line that begins with \"&lt;?xml\" is called a processing instruction, and\n  can be ignored for the sake of this lesson.\n</p>\n\n<h4>Parsing XML Documents</h4>\n<p>\n  If the last section was too abstract for you to digest, take a look at the\n  script editor for a real example. In the XML document created for the\n  <code>doc</code> variable, <code>&lt;I&gt;</code> is the root node. It is a\n  parent with one child, <code>&lt;L&gt;</code>. <code>&lt;L&gt;</code> is also\n  a parent to the two <code>&lt;U&gt;</code> nodes, and each\n  <code>&lt;U&gt;</code> is a parent to a <code>&lt;T&gt;</code> and an\n  <code>&lt;E&gt;</code>. Even those <code>&lt;T&gt;</code> and\n  <code>&lt;E&gt;</code> nodes are parents - their children are the value and\n  comment nodes they contain, but we'll get back to that later.\n</p>\n<p>\n  You'll notice that the XML string is being parsed into a DOM with\n  <code>XmlDocumentNode.from(xml: string | Buffer)</code>. This static method\n  returns an instance of the <code>XmlDocumentNode</code> class, which\n  represents an XML document for the given string/buffer.\n</p>\n\n<h4>The Root Node</h4>\n<p>\n  As mentioned before, the root of this document is <code>&lt;I&gt;</code>, as\n  it is the node from which everything else descends. To access it, you can use\n  the <code>doc</code>'s <code>child</code> property (the\n  <code>children</code> property is a list of all of a node's children, and\n  <code>child</code> is just an alias for <code>children[0]</code>).\n</p>\n<p>\n  In the vast majority of XML documents, and 100% of TS4 XML documents, the root\n  node is going to be an element. Elements are nodes that have a tag,\n  attributes, and children. You'll read more about these on the next page.\n</p>\n"},{"script":"const { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\n// There is no need to import XmlElementNode, since we're never using the class\n// itself or its constructor. Creating new XmlElementNodes will be covered on\n// a later page.\n\n// This is the same doc loaded on the last page, but we're using the `child`\n// property to get the root immediately -- remember, `root` is the <I> node,\n// which is an instance of the XmlElementNode class\nconst root = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"list_of_tuples\">\n    <U>\n      <T n=\"tunable\">67890<!--something--></T>\n      <E n=\"enum_value\">VALUE_1</E>\n    </U>\n    <U>\n      <T n=\"tunable\">24680<!--something_else--></T>\n      <E n=\"enum_value\">VALUE_2</E>\n    </U>\n  </L>\n</I>\n`).child;\n\n// ==================================================\n// Tags\n\n// Just for posterity, let's check the tag value again, make sure it's \"I\"\nSandbox.test('root.tag should be \"I\"', root.tag === \"I\");\n\n// Even though you'd probably never do this, it's possible to set the tag\nroot.tag = \"M\";\n\n// If you check the tag now, or write the XML as a string, you'll see that\n// the entire thing is now contained in `<M>...</M>`\n\n// ==================================================\n// Attributes\n\n// To access attributes, use `attributes`\nSandbox.test(\n  'root.attributes.n should be \"some_tuning\"',\n  root.attributes.n === \"some_tuning\"\n);\n\n// Some attributes, like `n`, have aliases\nSandbox.test('root.name should be \"some_tuning\"', root.name === \"some_tuning\");\n\n// To set an attribute's value, just set its key on the `attributes` object\nroot.attributes.n = \"fancy_new_name\";\nSandbox.output(`File name changed to \"${root.name}\"`);\n\n// If an attribute has an alias, you can also set that\nroot.name = \"fancier_newer_name\";\nSandbox.output(`File name changed to \"${root.attributes.n}\"`);\n\n// Notice how `attributes.n` and `name` are fully in sync with each other.\n// When you update one, the other changes -- that's because they're the exact\n// same thing. This also goes for all other attribute aliases.\n\n// One thing to be mindful of is that all attributes are parsed as strings.\n// Yes, even `s` -- if it were parsed as a number, it would lose precision.\nSandbox.test(\"root.id should be a string\", typeof root.id === \"string\");\n\n// If you need the tuning ID as a number, you MUST use a bigint -- numbers lose\n// precision after 53 bits, and tuning IDs can go up to 64 bits\nconst tuningID = BigInt(root.id);\nSandbox.test(\"tuningID should be a bigint\", typeof tuningID === \"bigint\");\n\n// ==================================================\n// Children\n\n// To access an element's children list, use `children`\nSandbox.test(\"root should only have one child\", root.children.length === 1);\n\n// You can also use `child` to get the first node in `children`\nSandbox.test(\"root's child should be an L tag\", root.child.tag === \"L\");\nSandbox.test(\n  'root\\'s child should ne named \"list_of_tuples\"',\n  root.child.name === \"list_of_tuples\"\n);\n","guide":"<h2>Element Nodes</h2>\n<p>\n  As mentioned on the last page, elements are nodes that have a tag, attributes,\n  and children. Elements in an S4TK XML DOM are represented with the\n  <code>XmlElementNode</code> class.\n</p>\n\n<h4>Tags</h4>\n<p>\n  Every element <strong>must</strong> have a tag. The tag is the value that\n  appears between <code>&lt;</code> and <code>&gt;</code> in the opening and\n  closing parts of the element node. For instance, the tag for\n  <code>&lt;I&gt;</code> is <code>I</code>.\n</p>\n<p>\n  You can get and set the tag of an <code>XmlElementNode</code> with its\n  <code>tag</code> property.\n</p>\n\n<h4>Attributes</h4>\n<p>\n  Elements may have attributes, but they are not required. Attributes are\n  key/value pairs that appear in the opening tag of an element node, such as\n  <code>n=\"name\"</code> in <code>&lt;T n=\"name\"&gt;</code>.\n</p>\n<p>\n  You can access an <code>XmlElementNode</code>'s attributes with its\n  <code>attributes</code> property, which is an object. To get, set, and delete\n  attributes, just edit <code>attributes</code> as you would any other object.\n</p>\n<p>\n  When setting the values of attributes, you can use strings, numbers, or\n  bigints. However, when an <code>XmlDocumentNode</code> is parsed, the value of\n  every attribute will always be a string. That is, even if the\n  <code>s</code> attribute contains the value <code>12345</code>, it will be\n  parsed as the string <code>\"12345\"</code> rather than the number\n  <code>12345</code>*.\n</p>\n<p class=\"footnote\">\n  * This is because the XML parser works with numbers only, not bigints. Numbers\n  in JavaScript lose precision after around 53 bits, and numbers in tuning can\n  be as high as 64 bits. If you need the tuning ID as a bigint, you must\n  manually parse the string with\n  <a\n    href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\"\n    target=\"_blank\"\n    ><code>BigInt()</code></a\n  >.\n</p>\n\n<h4>Attribute Aliases</h4>\n<p>\n  Some common attributes (<code>n</code>, <code>s</code>, and <code>t</code>)\n  also have aliases, to make working with them a bit easier (i.e. they have\n  properties on the node itself, rather than having to use\n  <code>attributes</code>).\n</p>\n<p>\n  To get the <code>n</code> attribute of a node, you can use <code>name</code>.\n  For <code>s</code>, you can use <code>id</code>. And finally, for\n  <code>t</code>, you can use <code>type</code>.\n</p>\n<p>\n  For any other attributes (like <code>c</code>, <code>m</code>, <code>i</code>,\n  and <code>p</code>), you <strong>must</strong> use the\n  <code>attributes</code> property and get them by name. These attributes do not\n  have aliases for two reasons:\n</p>\n<ol>\n  <li>You're unlikely to need them.</li>\n  <li>There are no good options*.</li>\n</ol>\n<p class=\"footnote\">\n  *<code>class</code>/<code>module</code> are reserved words and cannot be used\n  for <code>c</code>/<code>m</code>; <code>instanceType</code> is too long and\n  <code>type</code> is taken by <code>t</code>, neither is good option for\n  <code>i</code>; who cares about <code>p</code>?\n</p>\n\n<h4>Children</h4>\n<p>\n  As mentioned on the previous page, an element node can contain an arbitrary\n  number of other nodes, which are called its children. These children can\n  either be other element nodes (like an <code>&lt;L&gt;</code> that contains\n  <code>&lt;T&gt;</code>s), or they can be value nodes (like a\n  <code>&lt;T&gt;</code> that contains <code>0x12345678</code>).\n</p>\n<p>\n  You can get access an <code>XmlElementNode</code>'s children with its\n  <code>children</code> property. There is also the <code>child</code> property,\n  which is an alias for the first item in the children list\n  (<code>children[0]</code>).\n</p>\n\n<h4>Creating New Elements</h4>\n<p>\n  You've learned how to use <code>XmlElementNode</code>s once you have them, but\n  you may be wondering how you can create a new one to add to an existing DOM.\n</p>\n<p>\n  In order to do this, you need to read about value nodes, so let's do that\n  first on the next page.\n</p>\n"},{"script":"const { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\nconst root = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"list_of_tuples\">\n    <U>\n      <T n=\"tunable\">67890<!--something--></T>\n      <E n=\"enum_value\">VALUE_1</E>\n    </U>\n    <U>\n      <T n=\"tunable\">24680<!--something_else--></T>\n      <E n=\"enum_value\">VALUE_2</E>\n    </U>\n  </L>\n</I>\n`).child;\n\n// Using what you learned about elements, can you predict which node this is\n// before running the script and seeing the output?\nconst node = root.child.child.child;\nSandbox.output(`Tag: ${node.tag}, Name: ${node.name}`);\n\n// ==================================================\n// Getting Values\n\n// If you figured out what `node` is, can you guess what these two nodes are?\nconst [child1, child2] = node.children;\n// If you're unfamiliar with this syntax, it's equivalent to the following:\n// const child1 = node.children[0];\n// const child2 = node.children[1];\n\n// If you guessed these are a value and a comment, you're right. Since these are\n// nodes and not primitive values, you can use their `value` property to get the\n// actual string value that they contain. Can you guess what these next two\n// lines will output?\nSandbox.output(`Child 1 value: ${child1.value}`);\nSandbox.output(`Child 2 value: ${child2.value}`);\n\n// If you want the value within an element node without getting a reference to\n// the value/comment node directly, you can use `innerValue`. This is an alias\n// for `child.value`, and can be get and set. Do you know what will be output\n// by the next line?\nSandbox.output(`Node inner value: ${node.innerValue}`);\n\n// ==================================================\n// Setting Values\n\n// You can set the values just as easily. Can you guess what the output will\n// look like before running the script?\nchild1.value = 1234567890n;\nchild2.value = \"yeehaw\";\nroot.child.child.children[1].innerValue = \"SOMETHING\";\n\nSandbox.output(root.toXml());\n","guide":"<h2>Value & Comment Nodes</h2>\n<p>\n  Value nodes are much simpler than element nodes. They are just a single value,\n  such as a string, number, or boolean. Comments are even easier, as they are\n  just a string.\n</p>\n\n<h4>Getting & Setting Values</h4>\n<p>\n  You can get or set the value of both <code>XmlValueNode</code>s and\n  <code>XmlCommentNode</code>s with their <code>value</code> property.\n</p>\n<p>\n  If you have an element node and would like to get the value of the\n  value/comment node within it, you can use <code>innerValue</code> (an alias\n  for <code>child.value</code>).\n</p>\n<p>\n  Setting <code>value</code> to strings, numbers, and bigints should work as you\n  expect, but keep in mind that booleans will write with a capitalized first\n  letter (<code>True</code> and <code>False</code>).\n</p>\n\n<h4>Note on Parsed Values</h4>\n<p>\n  Like the attributes of elements, the XML parser always loads the value of an\n  <code>XmlValueNode</code> as a string, even if it's a number. This is again\n  due to precision errors with 64 bit numbers. If you need the value as a\n  number, you must parse it with\n  <a\n    href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt\"\n    target=\"_blank\"\n    ><code>BigInt()</code></a\n  >.\n</p>\n"},{"script":"const {\n  XmlDocumentNode,\n  XmlElementNode,\n  XmlValueNode,\n  XmlCommentNode,\n} = require(\"@s4tk/xml-dom\");\n\n// Starting with this document, let's add another tuple to \"some_list\"\nconst root = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"some_list\">\n    <U>\n      <T n=\"tunable\">11111<!--first--></T>\n      <E n=\"enum\">FIRST</E>\n    </U>\n  </L>\n</I>\n`).child;\n\n// ==================================================\n// Constructors\n\n// Remember that you can get \"some_list\" with `root.child`\n// Read the tutorial guide for more information about `addChildren()`\nroot.child.addChildren(\n  // You can create a new XmlElementNode with its constructor, which accepts an\n  // object with `tag`, `attributes`, and `children` properties. Tag is a string,\n  // attributes is an object of strings, and children is a list of nodes.\n  new XmlElementNode({\n    tag: \"U\",\n    children: [\n      new XmlElementNode({\n        tag: \"T\",\n        attributes: {\n          n: \"tunable\",\n        },\n        // To create a new value node, you can use its constructor and pass in\n        // a number, bigint, strings, or boolean. For comments, only strings\n        // are allowed\n        children: [new XmlValueNode(22222), new XmlCommentNode(\"second\")],\n      }),\n      new XmlElementNode({\n        tag: \"E\",\n        attributes: {\n          n: \"enum\",\n        },\n        children: [new XmlValueNode(\"SECOND\")],\n      }),\n    ],\n  })\n);\n\n// Now, let's see what the resulting XML document looks like\nSandbox.output(root.toXml());\n\n// As you can see, this worked! However, it is rather tedious to make nodes this\n// way, and sometimes may be more work than just writing the XML yourself. That's\n// where @s4tk/tunables comes in.\n\n// ==================================================\n// @s4tk/tunables\n\n// In regular scripts, all of your `require()` statements should be at the top\nconst { U, T, E } = require(\"@s4tk/tunables\");\n\nroot.child.addChildren(\n  U({\n    children: [\n      T({\n        name: \"tunable\",\n        value: 33333,\n        comment: \"third\",\n      }),\n      E({\n        name: \"enum\",\n        value: \"THIRD\",\n      }),\n    ],\n  })\n);\n\n// Now, let's again see what the resulting XML document looks like\nSandbox.output(\"\", root.toXml()); // just outputting \"\" for newline\n\n// As you can see, you get the same result with less, more readible code,\n// thanks to @s4tk/tunables. There is more to @s4tk/tunables than this, so be\n// sure to read those docs and check out its tutorial when you're done\n\n// ==================================================\n// Clones\n\n// This gets the first <U>, and returns a new node with the same properties\nconst clone = root.child.child.clone();\n\n// Now that you have a clone, you can edit it without affecting the original\nconst [t, e] = clone.children;\n\nt.innerValue = 44444;\nt.children[1].value = \"fourth\";\ne.innerValue = \"FOURTH\";\n\nroot.child.addChildren(clone);\n\n// Now, let's again see what the resulting XML document looks like\nSandbox.output(\"\", root.toXml()); // just outputting \"\" for newline\n","guide":"<h2>Creating New Nodes</h2>\n<p>\n  So far, you've seen how to parse an XML document and how to get/set individual\n  values within nodes. This page will show you how to create and add new nodes.\n</p>\n\n<h4>Using Constructors</h4>\n<p>\n  Each node type has its own respective constructor. You can check the\n  documentation linked above for more information about the expected arguments,\n  and the script editor for examples of them being used.\n</p>\n<p>\n  To actually add the new nodes after you create them with their constructors,\n  you can use the node's <code>addChildren()</code> method, which accepts an\n  arbitrary number of nodes to add to the end of the <code>children</code> list.\n</p>\n\n<h4>Using @s4tk/tunables</h4>\n<p>\n  There is an S4TK module that exists for the sole purpose of making this\n  process easier, it is called\n  <a href=\"https://sims4toolkit.com/#/docs/tunables\" target=\"_blank\"\n    >@s4tk/tunables</a\n  >.\n</p>\n<p>\n  This module contains helper functions that make your code more readible and\n  require less arguments. For instance, compare lines 32-41 with lines 69-73 in\n  the script editor.\n</p>\n\n<h4>Using Clones</h4>\n<p>\n  You can clone nodes with the <code>clone()</code> method. This will return a\n  deep copy of the node, meaning that it and all of its children are new\n  instances with the same values as before.\n</p>\n<p>\n  Once you have a clone, you can edit it. This is particularly handy when\n  dealing with lists, since their children tend to have similar, if not the\n  same, structure.\n</p>\n"},{"script":"const { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\nconst { T } = require(\"@s4tk/tunables\");\n\nconst root = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <T n=\"first\">1</T>\n  <T n=\"second\">2</T>\n  <T n=\"third\">3</T>\n</I>\n`).child;\n\n// ==================================================\n// Finding Children\n\n// To get the \"second\" node, you could use root.children[1], but that's not\n// very readible and is subject to break if any items are added or removed.\n// Instead, search for the node by name with findChild()\nconst secondNode = root.findChild(\"second\");\n\n// Let's verify that the node we got is what we expect. Remember, number values\n// are ALWAYS loaded as strings, due to precision issues with 64-bit numbers\nSandbox.test(\"secondNode's value should be 2\", secondNode.innerValue === \"2\");\n\n// ==================================================\n// Sorting Children\n\n// Let's add a <T n=\"fourth\">4</T>. Remember that addChildren() adds your node\n// to the end of the children list, so the result of this will be:\n//\n// <I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n//   <T n=\"first\">1</T>\n//   <T n=\"second\">2</T>\n//   <T n=\"third\">3</T>\n//   <T n=\"fourth\">4</T>\n// </I>\n//\n// While that makes numerical sense in this case, it wouldn't be best for real\n// tuning, where things should be sorted alphabetically.\n\nroot.addChildren(T({ name: \"fourth\", value: 4 }));\n\nSandbox.output(\"\\nBefore sorting:\", root.toXml());\n\nroot.sort();\n\nSandbox.output(\"\\nAfter sorting:\", root.toXml());\n","guide":"<h2>Methods</h2>\n<p>\n  Other than manually getting, setting, and adding parts of the DOM, there are\n  some helper methods that you may find useful.\n</p>\n\n<h4>Finding Children</h4>\n<p>\n  So far, you've been getting child nodes by their index. However, this is\n  pretty impractical, since you'll rarely know what the index is, and it is\n  likely to change whenever you update your file anyways.\n</p>\n<p>\n  That's where <code>findChild(name: string)</code> comes in. It will search the\n  children list for the first child that has the given name.\n</p>\n\n<h4>Sorting Children</h4>\n<p>\n  Keeping your tunables in alphabetical order by name is important for\n  readability, but can be tedious when you're programmatically adding children\n  to the end of the list.\n</p>\n<p>\n  And for this, we have <code>sort()</code>. This method can optionally accept a\n  function to use for sorting, but you're unlikely to need it - by default, it\n  will sort children alphabetically by their <code>n</code> attribute.\n</p>\n\n<h4>Writing XML Documents</h4>\n<p>\n  You've seen the <code>toXml()</code> method a few times now, but haven't been\n  told what it does. Simply put, it takes your XML DOM and turns it into a\n  string, so that you can log it, write it to a file, or save it in a package.\n  Admittedly, a better name would be toString(), but hindsight is 20/20.\n</p>\n"},{"script":"// Your objective is to start with the following XML document:\n//\n// <I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n//   <T n=\"tunable\">0<!--TODO--></T>\n//   <L n=\"list\" />\n// </I>\n//\n// And to turn it into the following:\n//\n// <I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n//   <L n=\"list\">\n//     <E>FIRST</E>\n//     <E>SECOND</E>\n//   </L>\n//   <T n=\"tunable\">67890<!--some_other_tuning--></T>\n// </I>\n\n// Write your code here\n\n// DO NOT WRITE BELOW THIS LINE! This will test that you did it correctly\n\nSandbox.test(\n  \"Challenge Completed\",\n  root.toXml() ===\n    `<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"list\">\n    <E>FIRST</E>\n    <E>SECOND</E>\n  </L>\n  <T n=\"tunable\">67890<!--some_other_tuning--></T>\n</I>`\n);\n","guide":"<h2>Challenge</h2>\n<p>Now that you've read about XML DOMs, let's put your skills to the test.</p>\n\n<h4>Importing from S4TK</h4>\n<p>\n  You're going to need <code>XmlDocumentNode</code>, so go ahead and import that\n  now. You can import other items as they're needed later.\n</p>\n\n<h4>Creating the Document</h4>\n<p>\n  You're allowed to create your document from the starting XML, just like the\n  previous pages told you. Go ahead and do that now, saving it to a variable\n  called <code>root</code>.\n</p>\n\n<h4>Update Tunable Values</h4>\n<p>\n  You'll need to get a reference to the <code>&lt;T&gt;</code> node, and then\n  change the value and comment in it.\n</p>\n\n<h4>Add Enums to List</h4>\n<p>\n  You'll need to get a reference to the <code>&lt;L&gt;</code> node, and then\n  add two <code>&lt;E&gt;</code> children with the correct values.\n</p>\n\n<h4>Sorting the Nodes</h4>\n<p>\n  Right now, you have a node named \"tunable\" coming before a node named \"list\".\n  These should be sorted alphabetically. Go ahead and do that, and you should be\n  all set.\n</p>\n"},{"script":"// There are many ways you could have done this challenge,\n// do not worry if the code doesn't match exactly\n\nconst { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\nconst { E } = require(\"@s4tk/tunables\");\n\nconst root = XmlDocumentNode.from(`\n<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <T n=\"tunable\">0<!--TODO--></T>\n  <L n=\"list\" />\n</I>\n`).child;\n\nconst tunable = root.findChild(\"tunable\");\n// you should always use bigints for tuning IDs\ntunable.children[0].value = 67890n;\ntunable.children[1].value = \"some_other_tuning\";\n\nconst list = root.findChild(\"list\");\nlist.addChildren(E({ value: \"FIRST\" }), E({ value: \"SECOND\" }));\n\nroot.sort();\n\nSandbox.test(\n  \"Challenge Completed\",\n  root.toXml() ===\n    `<I c=\"Class\" i=\"type\" m=\"path\" n=\"some_tuning\" s=\"12345\">\n  <L n=\"list\">\n    <E>FIRST</E>\n    <E>SECOND</E>\n  </L>\n  <T n=\"tunable\">67890<!--some_other_tuning--></T>\n</I>`\n);\n","guide":"<h2>Challenge Solution</h2>\n<p>\n  Congrats! You're done learning about XML DOMs for now. For more information,\n  visit the docs linked above.\n</p>\n<p>\n  Now that you understand XML DOMs, I'd recommend checking out\n  <a href=\"https://sims4toolkit.com/#/docs/tunables\" target=\"_blank\"\n    >@s4tk/tunables</a\n  >. It is an S4TK module of utility functions that make creating tuning DOMs\n  easier, such as the <code>T()</code> function that creates a\n  <code>&lt;T&gt;</code> node.\n</p>\n"}],"media":{}}