{"key":"tuning","pages":[{"script":"const { XmlResource } = require(\"@s4tk/models\");\nconst { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\n// Obviously real tuning would be longer, but this is just for example\nconst sampleTuning = `<I n=\"something\"/>`;\nconst sampleDom = XmlDocumentNode.from(sampleTuning);\n\n// ==================================================\n// Creating Tuning\n\n// No arguments for empty file\nconst emptyTuning = new XmlResource();\n\n// One string argument for file with initial content\nconst tuningFromString = new XmlResource(sampleTuning);\n\n// One DOM argument for file with initial content\nconst tuningFromDom = new XmlResource(sampleDom);\n\n// Loading a file buffer with from()\nconst buffer = await Sandbox.import(\"Sample.xml\");\nconst tuningFromBuffer = XmlResource.from(buffer);\n\n// ==================================================\n// The Content\n\n// Get the string content with `content`\nSandbox.output(`emptyTuning.content:\\n${emptyTuning.content}`);\nSandbox.output(`tuningFromString.content:\\n${tuningFromString.content}\\n`);\nSandbox.output(`tuningFromDom.content:\\n${tuningFromDom.content}\\n`);\nSandbox.output(`tuningFromBuffer.content:\\n${tuningFromBuffer.content}\\n`);\n\n// For tuningFromDom, you will see an extra line that begins with <?xml...\n// This is expected - XmlDocumentNode.toXml() automatically inserts it\n\n// Set the content with the same property\nemptyTuning.content = `<I n=\"no_longer_empty\"/>`;\nSandbox.output(`emptyTuning.content after setting:\\n${emptyTuning.content}\\n`);\n\n// The XML DOM will be discussed further on the next page, but for now, keep in\n// mind that setting the content to a new value will cause the DOM to regenerate\n\nSandbox.test(\n  \"tuningFromDom.dom should be the original DOM\",\n  tuningFromDom.dom === sampleDom\n);\n\nSandbox.output(\"Setting tuningFromDom.content...\");\ntuningFromDom.content = `<I n=\"something_else\"/>`;\n\nSandbox.test(\n  \"tuningFromDom.dom should now be a different DOM\",\n  tuningFromDom.dom !== sampleDom\n);\n","guide":"<h2>XmlResource</h2>\n<p>\n  When dealing with XML resources (like tuning or ASMs), you'll need to use the\n  <code>XmlResource</code> class from @s4tk/models.\n</p>\n<p class=\"footnote\">\n  This tutorial assumes that you are familiar with @s4tk/xml-dom. If you are\n  not, you should read the <a href=\"#/tutorials/xml-dom\">XML DOMs tutorial</a>\n  before this one.\n</p>\n\n<h4>Creating New Tuning</h4>\n<p>\n  To create a new, empty tuning file, you can use\n  <code>new XmlResource()</code> with no arguments.\n</p>\n<p>\n  If you have initial content to use, you can pass either a string or an\n  <code>XmlDocumentNode</code> (from @s4tk/xml-dom) as an argument to the\n  constructor.\n</p>\n\n<h4>Loading Tuning From File</h4>\n<p>\n  Like all other resources, the <code>XmlResource</code> class has a static\n  <code>from(buffer: Buffer)</code> method that can be used to load an existing\n  tuning file into an <code>XmlResource</code> object.\n</p>\n<p>\n  This tutorial supplies a sample tuning file called \"Sample.xml\", and you can\n  load it as a buffer with <code>Sandbox.import()</code>.\n</p>\n\n<h4>The Content</h4>\n<p>\n  The \"content\" of an XML resource is a string that contains its XML as plain\n  text. You can get/set* it with the <code>content</code> property.\n</p>\n<p>\n  The content is the source of truth for XML resources. That is, it is used in\n  <code>getBuffer()</code>, so whatever the content is is what gets written to\n  files and packages.\n</p>\n<p class=\"footnote\">\n  * Setting <code>content</code> will regenerate the DOM. There is a somewhat\n  complex relationship between the content and DOM. This will be discussed\n  further on the next page.\n</p>\n"},{"script":"// TODO:\nconst { XmlResource } = require(\"@s4tk/models\");\nconst { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\n// Obviously real tuning would be longer, but this is just for example\nconst sampleTuning = `<I n=\"something\"/>`;\nconst sampleDom = XmlDocumentNode.from(sampleTuning);\n\n// ==================================================\n// Creating Tuning\n\n// No arguments for empty file\nconst emptyTuning = new XmlResource();\n\n// One string argument for file with initial content\nconst tuningFromString = new XmlResource(sampleTuning);\n\n// One DOM argument for file with initial content\nconst tuningFromDom = new XmlResource(sampleDom);\n\n// ==================================================\n// The Content\n\n// Get the string content with `content`\nSandbox.output(`emptyTuning.content: ${emptyTuning.content}\\n`);\nSandbox.output(`tuningFromString.content:\\n${tuningFromString.content}\\n`);\nSandbox.output(`tuningFromDom.content:\\n${tuningFromDom.content}\\n`);\n\n// Set the content with the same property\nemptyTuning.content = `<I n=\"no_longer_empty\"/>`;\nSandbox.output(`emptyTuning.content after setting:\\n${emptyTuning.content}\\n`);\n\n// Note that setting the content will regenerate the DOM\nSandbox.test(\n  \"tuningFromDom.dom === sampleDom\",\n  tuningFromDom.dom === sampleDom\n);\n\nSandbox.output(\"Setting tuningFromDom.content...\");\ntuningFromDom.content = `<I n=\"something_else\"/>`;\n\nSandbox.test(\n  \"tuningFromDom.dom !== sampleDom\",\n  tuningFromDom.dom !== sampleDom\n);\n\n// ==================================================\n// The DOM\n\n// Note that `root` is an alias for `dom.child`, so we'll be using that instead\nSandbox.test(\n  \"dom.child === root\",\n  tuningFromString.dom.child === tuningFromString.root\n);\n\n// Since the dom/root are XmlNodes, you can use them like you learned in the\n// XML DOMs tutorial, such as getting the `n` attribute with `name`\nSandbox.output(`tuningFromString.root.name: ${tuningFromString.root.name}\\n`);\n\n// IMPORTANT: Editing the dom/root does NOT automatically update the content,\n// for instance, check the output for the following:\nSandbox.output(\"About to edit tuningFromString's DOM...\");\ntuningFromString.root.name = \"newer_name\";\nSandbox.output(`tuningFromString.content: ${tuningFromString.content}`);\n\n// ==================================================\n// Editing the DOM\n\n// As you can see, the content still thinks the name is \"something\". However,\n// just like setting the `content` property refreshes the DOM, setting the `dom`\n// property refreshes the content.\ntuningFromString.dom = tuningFromDom.dom;\nSandbox.output(\n  `tuningFromString.content after setting dom: ${tuningFromString.content}`\n);\n\n// That works, but it's a little weird, unreadible, and easy to forget. A better\n// way to ensure the content stays in sync is by using `updateDom()` and\n// `updateRoot()`. They both accept a function as an argument, and that function\n// should expect either the dom or the root as its argument. It will call the\n// function, and once it terminates, it'll update the content accordingly.\ntuningFromString.updateDom((dom) => {\n  dom.child.name = \"even_newer_name\";\n});\n\nSandbox.output(\n  `tuningFromString.content after updateDom(): ${tuningFromString.content}`\n);\n\ntuningFromString.updateRoot((root) => {\n  root.name = \"newest_name\";\n});\n\nSandbox.output(\n  `tuningFromString.content after updateRoot(): ${tuningFromString.content}`\n);\n","guide":"<h2>The XML DOM</h2>\n<p>\n  Assuming its content is valid XML, you can access an XML resource's DOM with\n  its <code>dom</code> property.\n</p>\n\n<h4>Accessing The DOM</h4>\n<p>\n  The DOM is an <code>XmlDocumentNode</code>, and can be get/set* with the\n  <code>dom</code> property. Since you're almost always going to want the DOM's\n  child, the root, you can also use the <code>root</code> property (an alias for\n  <code>dom.child</code>).\n</p>\n<p>\n  It's important to note that editing the DOM does\n  <strong>NOT</strong> automatically update the content. And, since the content\n  is the source of truth, that means that edits made to the DOM will not be\n  reflected the next time you use <code>content</code> or call\n  <code>getBuffer()</code>.\n</p>\n<p class=\"footnote\">\n  * When setting <code>dom</code>/<code>root</code>, note that the\n  <code>content</code> property gets automatically reset to the value of\n  <code>dom.toXml()</code>.\n</p>\n\n<h4>Editing The DOM</h4>\n<p>\n  Since editing the DOM does not automatically update the content, you have two\n  options:\n</p>\n<ul>\n  <li>\n    Set the <code>dom</code> property equal to itself after you make your edits,\n    which will then set <code>content</code> equal to <code>dom.toXml()</code>*\n  </li>\n  <li>\n    Edit the DOM using the <code>updateDom()</code> / <code>updateRoot()</code>\n    methods, which automatically update the content when they finish\n  </li>\n</ul>\n<p>\n  While there's nothing wrong with setting the DOM to itself, it is less\n  readible and more prone to error (e.g. forgetting what it's for and deleting\n  it, or forgetting to do it in the first place).\n</p>\n<p>\n  So, the second approach (using the <code>updateDom()</code> /\n  <code>updateRoot()</code> methods) is preferred, and it's good to get into the\n  habit of using them right away.\n</p>\n<p class=\"footnote\">\n  * You may be thinking that <code>content = dom.toXml()</code> is a third\n  option, but it is strongly discouraged, as doing so would delete the DOM and\n  require it to be regenerated.\n</p>\n"}],"media":{"Sample.xml":"PEkgbj0idGhpc19jYW1lX2Zyb21fYV9maWxlIi8+"}}