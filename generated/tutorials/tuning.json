{"key":"tuning","pages":[{"script":"const { XmlResource } = require(\"@s4tk/models\");\nconst { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\n// Obviously real tuning would be longer, but this is just for example\nconst sampleTuning = `<I n=\"something\"/>`;\nconst sampleDom = XmlDocumentNode.from(sampleTuning);\n\n// ==================================================\n// Creating Tuning\n\n// No arguments for empty file\nconst emptyTuning = new XmlResource();\n\n// One string argument for file with initial content\nconst tuningFromString = new XmlResource(sampleTuning);\n\n// One DOM argument for file with initial content\nconst tuningFromDom = new XmlResource(sampleDom);\n\n// Loading a file buffer with from()\nconst buffer = await Sandbox.import(\"Sample.xml\");\nconst tuningFromBuffer = XmlResource.from(buffer);\n\n// ==================================================\n// The Content\n\n// Get the string content with `content`\nSandbox.output(`emptyTuning.content:\\n${emptyTuning.content}`);\nSandbox.output(`tuningFromString.content:\\n${tuningFromString.content}\\n`);\nSandbox.output(`tuningFromDom.content:\\n${tuningFromDom.content}\\n`);\nSandbox.output(`tuningFromBuffer.content:\\n${tuningFromBuffer.content}\\n`);\n\n// For tuningFromDom, you will see an extra line that begins with <?xml...\n// This is expected - XmlDocumentNode.toXml() automatically inserts it\n\n// Set the content with the same property\nemptyTuning.content = `<I n=\"no_longer_empty\"/>`;\nSandbox.output(`emptyTuning.content after setting:\\n${emptyTuning.content}\\n`);\n\n// The XML DOM will be discussed further on the next page, but for now, keep in\n// mind that setting the content to a new value will cause the DOM to regenerate\n\nSandbox.test(\n  \"tuningFromDom.dom should be the original DOM\",\n  tuningFromDom.dom === sampleDom\n);\n\nSandbox.output(\"Setting tuningFromDom.content...\");\ntuningFromDom.content = `<I n=\"something_else\"/>`;\n\nSandbox.test(\n  \"tuningFromDom.dom should now be a different DOM\",\n  tuningFromDom.dom !== sampleDom\n);\n","guide":"<h2>XmlResource</h2>\n<p>\n  When dealing with XML resources (like tuning or ASMs), you'll need to use the\n  <code>XmlResource</code> class from @s4tk/models.\n</p>\n<p class=\"footnote\">\n  This tutorial assumes that you are familiar with @s4tk/xml-dom. If you are\n  not, you should read the <a href=\"#/tutorials/xml-dom\">XML DOMs tutorial</a>\n  before this one.\n</p>\n\n<h4>Creating New Tuning</h4>\n<p>\n  To create a new, empty tuning file, you can use\n  <code>new XmlResource()</code> with no arguments.\n</p>\n<p>\n  If you have initial content to use, you can pass either a string or an\n  <code>XmlDocumentNode</code> (from @s4tk/xml-dom) as an argument to the\n  constructor.\n</p>\n\n<h4>Loading Tuning From File</h4>\n<p>\n  Like all other resources, the <code>XmlResource</code> class has a static\n  <code>from(buffer: Buffer)</code> method that can be used to load an existing\n  tuning file into an <code>XmlResource</code> object.\n</p>\n<p>\n  This tutorial supplies a sample tuning file called \"Sample.xml\", and you can\n  load it as a buffer with <code>Sandbox.import()</code>.\n</p>\n\n<h4>The Content</h4>\n<p>\n  The \"content\" of an XML resource is a string that contains its XML as plain\n  text. You can get/set* it with the <code>content</code> property.\n</p>\n<p>\n  The content is the source of truth for XML resources. That is, it is used in\n  <code>getBuffer()</code>, so whatever the content is is what gets written to\n  files and packages.\n</p>\n<p class=\"footnote\">\n  * Setting <code>content</code> will regenerate the DOM. There is a somewhat\n  complex relationship between the content and DOM. This will be discussed\n  further on the next page.\n</p>\n"},{"script":"const { XmlResource } = require(\"@s4tk/models\");\nconst { E } = require(\"@s4tk/tunables\");\n\nconst trait = new XmlResource(`\n<I c=\"Trait\" i=\"trait\" m=\"traits.traits\" n=\"some_trait\" s=\"12345\">\n  <L n=\"ages\">\n    <E>YOUNGADULT</E>\n    <E>ADULT</E>\n  </L>\n  <E n=\"trait_type\">HIDDEN</E>\n</I>\n`);\n\n// ==================================================\n// Accessing the DOM\n\n// You can use the DOM like you learned in the XML DOMs tutorial\nSandbox.output(`Filename: ${trait.root.name}`);\nSandbox.output(`Tuning ID: ${trait.root.id}\\n`);\n\n// ==================================================\n// Content vs. DOM\n\n// IMPORTANT: Editing nodes within the DOM will *NOT* sync the content!\n// For instance, let's edit something in the DOM and then view the `content`\ntrait.root.name = \"new_trait\";\nSandbox.output(`After changing name to 'new_trait':${trait.content}`);\n\n// As seen in the output, the content still thinks the name is 'some_trait'...\n\n// ==================================================\n// Editing the DOM\n\n// To sync the content with the previous edit, we can set `dom` equal to itself,\n// since this will notify the XML resource that its DOM has changed and that it\n// needs to update the content to match\ntrait.dom = trait.dom;\nSandbox.output(`After setting 'dom = dom':\\n${trait.content}\\n`);\n\n// That works, but it's a little weird and easy to forget...\n\n// A better way to ensure the content stays in sync is by using updateRoot().\n// There is also an updateDom() method, but updateRoot() is more convenient.\n// It accepts a function as an argument, and that function accepts the root as\n// an argument. If you're new to JavaScript, this might sound confusing, but\n// just take a look at an example:\n\ntrait.updateRoot((root) => {\n  // updating the name, just like before\n  root.name = \"even_newer_trait\";\n\n  // and also adding in a whole new node, cause why not?\n  root.findChild(\"ages\").addChildren(E({ value: \"ELDER\" }));\n});\n\n// () => { } is just how you create an anonymous function in JavaScript - this\n// function gets passed into the updateRoot() method, which will then call the\n// anonymous function that you provided\n\nSandbox.output(`After updateRoot():\\n${trait.content}`);\n","guide":"<h2>The DOM</h2>\n<p>\n  The content is plain text - it knows nothing about XML structure. If you want\n  to edit a tuning document, you have to use its DOM.\n</p>\n\n<h4>Accessing the DOM</h4>\n<p>\n  The DOM is an <code>XmlDocumentNode</code> (from @s4tk/xml-dom), and can be\n  accessed with the <code>dom</code> property.\n</p>\n<p>\n  Since you're almost always going to want the DOM's child (i.e. the root), you\n  can also use the <code>root</code> property, which is an alias for\n  <code>dom.child</code>.\n</p>\n<p>\n  Once you have the DOM/root, you can get and set the values of nodes as you\n  learned to do in the <a href=\"#/tutorials/xml-dom\">XML DOMs tutorial</a>.\n</p>\n\n<h4>Content vs. DOM</h4>\n<p>\n  As mentioned previously, setting the <code>content</code> property will cause\n  the DOM to regenerate. The inverse is also true - setting the\n  <code>dom</code> property will automatically set the value of\n  <code>content</code> to the result of <code>dom.toXml()</code>.\n</p>\n<p>\n  <strong class=\"danger\">IMPORTANT:</strong> Editing nodes within the DOM will\n  <em>not</em> automatically sync the content! Since the content is what is used\n  in <code>getBuffer()</code>, your changes to the DOM will <em>not</em> be\n  reflected when you write the tuning to a file.\n</p>\n<p>So... how do you save your changes to the DOM?</p>\n\n<h4>Editing the DOM</h4>\n<p>Since editing the DOM does not update the content, you have two options:</p>\n<ul>\n  <li>\n    Set the <code>dom</code> property equal to itself after you make your edits,\n    which will then set <code>content</code> equal to <code>dom.toXml()</code>*\n  </li>\n  <li>\n    Edit the DOM using <code>updateDom()</code> or <code>updateRoot()</code>,\n    which update the content when they finish\n  </li>\n</ul>\n<p>\n  Setting the DOM equal to itself is less readible and more prone to error, so\n  using <code>updateDom()</code> / <code>updateRoot()</code> is preferred.\n</p>\n<p class=\"footnote\">\n  * If you're thinking of using <code>content = dom.toXml()</code> yourself,\n  Just Don't&#8482;. It is strongly discouraged as it would unnecessarily reset\n  the DOM.\n</p>\n"},{"script":"const { XmlResource } = require(\"@s4tk/models\");\nconst { XmlDocumentNode } = require(\"@s4tk/xml-dom\");\n\nconst trait = new XmlResource(\n  XmlDocumentNode.from(`\n<I c=\"Trait\" i=\"trait\" m=\"traits.traits\" n=\"some_trait\" s=\"12345\">\n  <L n=\"ages\">\n    <E>YOUNGADULT</E>\n    <E>ADULT</E>\n  </L>\n  <E n=\"trait_type\">HIDDEN</E>\n</I>\n`)\n);\n\n// 1) Get the buffer\nconst buffer = trait.getBuffer();\n\n// 2) Write the buffer (in Node, you'd use `fs.writeFileSync()`)\nSandbox.download(\"SomeTrait.xml\", buffer);\n","guide":"<h2>Writing to Files</h2>\n<p>\n  Sometimes, you may want to write an <code>XmlResource</code>'s content to an\n  XML file, such as when you're extracting tuning from the game.\n</p>\n\n<h4>Getting the Buffer</h4>\n<p>\n  Like every other resource, you can get an <code>XmlResource</code>'s buffer\n  with <code>getBuffer()</code>. Once you have the buffer, you can write it to a\n  file using whatever your environment allows.\n</p>\n<p class=\"footnote\">\n  In Node, you'd use the\n  <a href=\"https://nodejs.org/api/fs.html\" target=\"_blank\">fs</a> module to\n  write your buffer to a file, rather than <code>Sandbox.download()</code>.\n</p>\n"},{"script":"","guide":""},{"script":"","guide":""}],"media":{"Sample.xml":"PEkgbj0idGhpc19jYW1lX2Zyb21fYV9maWxlIi8+"}}